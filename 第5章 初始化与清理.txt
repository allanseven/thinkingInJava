第5章 初始化与清理

5.1 用构造器确保初始化
		1-构造器与类名相同
			 1.与其他方法区分开
			 2.确保编译器能准确调用构造方法
		2-默认构造器和有参构造
		3-没有返回值，没有void
5.2 方法重载
		1-方法重载原因：
			 1.构造器
			 2.重新定义相同标识方法的含义
		2-区分重载方法：
			 1.通过不同的参数列表
			 2.参数列表不同：参数类型、个数、顺序至少有一个不相同。
		3-涉及基本类型的重载
			 1.当传入的数据类型小于参数类型，数据类型会隐式转换
			 2.当传入的参数类型大于参数类型，数据类型会要求强制转换
		4-无法以返回值区分重载方法
			 1.void f(){};
			 2.int f(){return 1};
			 3.f();	--这种情况无法判断调用那个f();
5.3 缺省构造器
		1-如果类中没有构造器，编译器会自动创建默认构造器
		  如果已经定义一个构造器，编译器不会自动创建默认构造器
		
5.4 this关键字
		1-编译器把“所操作对象的引用”作为第一参数传递给方法
		  即: Banana.peel(a, 1)
		2-this只能在方法内部使用，表示对“调用方法的那个对象”的引用
		3-在方法内部调用同一个类的另一个方法，不必使用this，直接调用。
		4-this关键字对于将当前对象传递给其他方法
		5-在构造器中调用构造器
			 1.this添加参数列表：表示调用某个符合该参数列表的构造器
			 2.只可以用this调用一个构造器，不能调用两个
			 3.局部变量和成员变量同名时，this明确调用成员变量
			 4.除构造器外，不能在方法中通过this调用构造器
		6-static方法:
			 1.static方法中没有this
			 2.static方法中不可以调用非静态方法，反之可以
			   特殊，通过传递一个对象引用到静态方法中，再通过这个对象调用非静态方法
			 3.Java中禁止使用全局方法，但在类中置入static方法，就可以访问其他static方法和static域
		
5.5 清理：终结处理和垃圾回收
		1-针对特殊的非new对象，Java的Object类中定义了通用的清理方法finalize()
		2-误把finalize()当作C++中的析构函数
			 1.C++中对象一定会被销毁
			 2.Java中的对象并不总是被垃圾回收
		3-finalize()的用途：
			 1.垃圾回收只与内存有关
			 2.发生在本地方法的情况下被调用
			 3.本地方法只支持C和C++，但可以通过它们调用其他语言的代码
		4-终结的条件
			 1.对象终结条件的验证
			 2.通过标记对象，验证是否回收
		5-垃圾回收器如何工作：
			 1.引用计数：每个对象都含有一个引用计数--但未被应用
			 2.对任何活的对象，一定能最终追溯到其存活在堆栈或静态存储区中的引用
			 3.停止-复制：把当前堆存活的的对象复制到另一堆，并重新排列
			 4.标记-扫除：当程序稳定，可能只产生少量垃圾或没有垃圾时
			 5.即使编译器技术：把程序翻译成本地机器码
			 6.惰性评估：编译器只有在必要的时候才编译代码
		
5.6 成员初始化
		1-局部变量必须初始化，否则报编译错误
		2-基础数据类型的成员变量，编译器会自动赋默认值
			 1.对象引用默认值为null
		3-指定初始化
			 1.定义时，赋值
			 2.非基本类型的对象如未初始化就使用，报运行时错误
			 3.通过方法提供初始化，如有参数，该参数必须初始化
		
5.7 构造器初始化
		1-在构造器中会自动初始化基本类型的成员和对象，无论它们之前是否初始化
		2-初始化顺序：
			 1.变量定义的顺序决定了初始化的顺序
			 2.成员变量定义散布于方法定义之间，它们会在任何方法被调用之前被初始化
		3-静态数据的初始化：
			 1.静态数据只占用一份存储区域
			 2.static关键字不能修饰局部变量，只能作用域
			 3.静态数据只有在需要时才初始化
			 4.静态对象初始化优先于非静态对象
		4-一个对象的创建过程：
			 1.构造器可以看作静态方法，因此，当首次创建一个对象或访问静态方法和静态域时，
			   Java解释器先查找类路径，定位.class文件
			 2.载入.class，有关静态初始化的所有动作都会执行
				 --静态初始化只在Class对象首次加载的时候进行一次
			 3.使用new创建对象时，在堆上为对象分配存储空间
			 4.这块存储空间会被清零，自动将对象中的所有基本数据类型设置为默认值，引用为null
			 5.执行所有定义字段的初始化动作
			 6.执行构造器
		5-显示的静态初始化
			 1.静态子句--静态代码块
			    static{	}
			 2.当首次生成一个类的对象或访问那个类的静态数据成员时，初始化，
			   只执行一次
		6-非静态实例初始化	
			 1.实例初始化/构造代码块：初始化每个对象的非静态变量
				{ }，一般在构造方法附近
			 2.每调用一次构造器，构造代码块都会执行一次
5.8 数组初始化
		1-是相同类型，用一个标识符名称封装到一起的一个对象序列或基本类型数据序列
		2-定义：int[] a;
		3-数组最大下标：length-1
		4-初始化数组：
			 1.int[] arr = new int[3];
			 2.int[] arr = new int[]{1,2,3};
			 3.int[] arr = {1,2,3};
		5-可变参数列表：
			 1.用Object[]对象数组代替可变参数列表
			 2.直接定义可变参数列表(Object...args)
			 3.可将0个参数传递给可变参数列表：printArray();
			 4.可变参数列表和自动包装机制
			   重载时，当f()，会报错，编译器无法知道调用那个重载方法
					   当重载方法f(float i, Character... args)
							     f(Character... args)
								 f(1, 'a');
								 f('a', 'b');--会报错，编译器无法识别
								 添加一个非可变参数解决		
5.9 枚举类型
		1-enum关键字
		2-创建枚举类型时，编译器会自动添加特性：
			 1.toString()--显示enum常量实例名字
			 2.ordinal()--声明enum常量顺序
			 3.values()--显示enum常量数组
		3-enum与switch结合使用
5.10 总结





