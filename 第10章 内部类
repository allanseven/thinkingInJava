第10章 内部类

10.1 创建内部类
		1-把内部类定义在外部类的里面
		2-在非静态方法之外创建内部类对象，通过：外部类.内部类对象 
		
10.2 链接到外部类
		1-内部类具有名字隐藏和组织代码的作用		
		2-内部类和外部类之间有关联，因此，内部类不需任何条件，就可以访问外部类的所有成员
		3-内部类的构造器中隐式的包含外部类对象的引用：
		    成员位置：final Sequence this$0;
			构造器中：this$0 = Sequence.this;
					  super();
		
10.3 使用this与new
		1-创建外部类应用对象：外部类名.this
		2-外部类要想访问内部类成员，必须创建对象
					 1.成员内部类不是静态的：
							 外部类名.内部类名 对象名 = new 外部类名.new 内部类名();
					 2.成员内部类是静态的：
							 外部类名.内部类名 对象名 = new 外部类名().内部类名();
					     --静态内部类中是静态方法：外部类名.内部类名.静态方法()//可省略外部类名
	
10.4 内部类与向上转型
		1-private内部类实现接口，通过公共的方法生成指向接口的内部类对象
		  这种方式完全阻止任何依赖于类型的编码，完全隐藏了实现细节
		
10.5 在方法和作用域内的内部类
		1-局部内部类在方法的作用域中
		2-可以在不同的方法的作用域中创建相同名称标识的内部类
		3-在任意的作用域嵌入内部类，如if语句，
		  它的编译与if语句的条件无关，只能作用于此范围内
		
10.6 匿名内部类
		1-在匿名对象中定义内部类
			 public Wrapping wrapping(int x) {
			 // Base constructor call:
			 return new Wrapping(x) { // 传递构造函数参数。
			 public int value() {
				return super.value() * 47;
			 }
			}; //分号标记表达式的结束
		  }
		2-如果定义一个匿名内部类，让它使用一个在外部定义的成员，
		  编译器会要求其参数引用是final//final作用防止数据在方法体中被修改
		  现在版本方法中形式参数的改变无法影响方法外的值，容器类除外
		3-通过实例初始化，达到为匿名内部类创建一个构造器的效果
		4-匿名内部类不能同时兼容扩展类和实现接口，如果实现接口，也只能实现一个
		5-再访问工厂方法：通过静态成员匿名方式生成工厂类
		
10.7 嵌套类
		1-如果不需要内部类与外部类之间的联系，可以把内部类声明为static--嵌套类
			 1.要创建嵌套类对象，不需要外部类对象
			 2.不能从嵌套类对象中访问非静态的外部类对象
		2-普通内部类的字段与方法，只能放在类的外部层次上，所以，它不能有static数据和static字段，也不能包含嵌套类
		  而嵌套类包含，就像一个static方法
		3-接口内部的类
			 1.在接口中的类是public和static
			 2.接口中的嵌套类可以实现外部接口本身
			 3.通过嵌套类放置测试代码，生成独立的类，再生产时，可直接删除，不会产生额外的多余代码
			     public static class Tester {
				 public static void main(String[] args) {
				  TestBed t = new TestBed();
				  t.f();
				}
			  }
		4-从多重嵌套类中访问外部类的成员
		
10.8 为什么需要内部类
		1-每个内部类都可以继承一个接口的实现，有效实现多重继承
		2-如果实现多个接口：两者没有区别
			 1.单一类
			 2.内部类
		3-如果是抽象类或具体类，只能使用内部类
		4-内部类的特性:
			 1.内部类可以有多个实例，每个实例都有自己的状态信息，与外部类对象的信息相互独立
			 2.在单个外部类中，可以让多个内部类实现同一个接口或继承同一个类
			 3.内部类没有is-a关系，是一个独立的实体
		5-闭包与回调：
			 1.闭包是一个可调用的对象，记录信息，信息来自创建的作用域
			 2.内部类是面向对象的闭包
			 3.通过回调，对象能够携带一些信息，这些信息允许它在稍后的某个时刻调用初始的对象
			 4.但创建一个内部类时，并没有在外部类的接口中添加东西，也没有修改外围类的接口
			 5.在内部类方法中通过Callee2.this.increment();调用外部类的increment()
		6-内部类与控制框架
			 1.设计模式总是把变化的事物和不变的事物分离开
			   模板方法模式：模板方法是不变的，可覆盖的方法是变化的
			 2.控制框架是一种特殊的应用程序框架--解决特定问题的一个类或一组类
			 3.命令设计模式
		
10.9 内部类的继承
		1-只继承内部类，而不是外部类，生成构造器时，必须加
		     外部类.super();
		
10.10 内部类可以被覆盖吗
		1-当继承某个外部类时，无法覆盖其内部类
		2-内部类继承内部类，可以覆盖其中的方法
		
10.11 局部内部类
		1-局部内部类不能有访问修饰符，因为它不是外部类的一部分，
		  但可以访问当前代码块中的常量和外部类的所有成员
		2-为什么使用局部内部类而不是匿名内部类的原因：
			 1.需要一个已命名的构造器或需要重载构造器
			 2.需要不止一个内部类的对象
		
10.12 内部类标识符
		1-内部类class文件命名：外部类$内部类
		2-如果是匿名，则简单产生一个数字作为其标识符
		3-如果是在别的内部类中，直接在 外部类$ 后面添加
		
10.13 总结











