第8章 多态

8.1 再论向上转型
		1-多态通过分离做什么和怎么做，从另一个角度将接口和实现分离开来
			 作用：消除类型之间的耦合关系
		2-忘记对象类型
			 1.仅接受基类为参数，而不管特殊的导出类
		
8.2 转机
		1-方法调用绑定
			 1.后期绑定/动态绑定：在运行时，根据对象的类型进行绑定
			 2.java中除static方法和final方法外，其他方法都是后期绑定
			 3.产生正确的行为
		2-可扩展性
			 1.对基类的新增扩展，不会影响操作基类接口的方法
		3-缺陷：覆盖私有方法
		     1.基类中方法被final，无法通过多态机制访问
		4-缺陷：域与静态方法
			 1.任何域的访问操作都由编译器解析，因此不是多态
			 2.方法是静态的，它的行为就不具有多态性
			   静态方法是与类，而非单个对象相关联
8.3 构造器和多态
		1-构造器不具有多态性
		2-构造器的调用顺序
			 1.在其他任何事务发生之前，将分配给对象的存储空间初始化为二进制的0
			 2.调用基类的构造器，从该层次的根类，一直递归到最低的导出类			  
			   如果没有明确调用某个基类构造器，将会调用默认构造器
			 3.按照声明顺序调用成员的初始化方法
			 4.调用导出类构造器的主体
		3-继承与清理
			 1.某个子对象依赖于其他对象，销毁的顺序应该和初始化的顺序相反
			 2.对于字段：与生命的顺序相反
			 3.对于基类：应先清理导出类，再清理基类
				 
		4-构造器内部的多态方法的行为
			 1.在基类中调用被覆盖的方法时，有可能发生所需要的成员未定义初始化，显示默认值
			 2.准则：“用尽可能简单的方法使对象进入正常状态，如果可以的话，避免调用其他方法”
			   唯一能安全调用的是final方法/private方法
				 			 
8.4 协变返回类型
		1-协变返回类型允许导出类返回与基类不同的类型，
		  在早期版本只能返回与基类方法返回的类型一致
		
8.5 用继承进行设计
		1-状态模式：在运行期不能决定继承不同的对象，而在编译期确定
		2-准则：用继承表达行为间的差异，并用字段表达状态上的变化
		3-纯继承与扩展
			 1.纯替代：is a       是一种
			 2.扩展：  is like a  像一个
			 3.向上转型无法调用扩展的方法，丢失具体的类型信息
		4-向下转型与运行时类型识别
			 1.在Java中，所有转型都会得到检查--运行时类型识别
			 2.格式：(类型)
		
8.6 总结






